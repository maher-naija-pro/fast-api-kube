services:
 # API service for FastAPI
  api:
    build: 
      context: .
      dockerfile: Dockerfile
    command: >
      bash -c "alembic upgrade head
      && hypercorn src/main:app -b 0.0.0.0:3000 --reload  --access-logfile -  --graceful-timeout 0"

    develop:
      watch:
        - action: sync
          path: ./src/
          target: /app/src/
        - action: rebuild
          path: requirements/dev.txt
    image: fastapiapp:latest
    ports:
      - 3000:3000 # Expose port 3000 for the API service
    volumes:
      - type: bind
        source: .
        target: /app/
    depends_on:
       db:
          condition: service_healthy
    environment: 
        - DB_URI=postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db/${POSTGRES_DB}
    restart: always # Automatically restart the service if it fails
    logging:
      driver: "local" # Use local logging for better performance and easier troubleshooting
    networks:
      - app_network  # Adding the service to the same dedicated network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]  # Health check to call the /health endpoint
      interval: 10s  # Check every 10 seconds
      timeout: 5s  # Timeout after 5 seconds
      retries: 3  # Retry 3 times before marking the service as unhealthy
      start_period: 30s  # Wait 30 seconds before starting the health checks
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M # Limit CPU and memory usage for the api service

  test:
    build: 
      context: .
      dockerfile: Dockerfile
    command:  bash -c "alembic upgrade head && pytest"
    develop:
      watch:
        - action: sync
          path: ./
          target: /app/
        - action: rebuild
          path: requirements/dev.txt
    image: fastapiapp:latest
    ports:
      - 4000:3000 # Expose port 3000 for the API service
    volumes:
      - type: bind
        source: .
        target: /app/
    depends_on:
       db:
          condition: service_healthy

    environment: 
        - DB_URI=postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db/${POSTGRES_DB}
    networks:
      - app_network  # Adding the service to the same dedicated network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]  # Health check to call the /health endpoint
      interval: 10s  # Check every 10 seconds
      timeout: 5s  # Timeout after 5 seconds
      retries: 3  # Retry 3 times before marking the service as unhealthy
      start_period: 30s  # Wait 30 seconds before starting the health checks

    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M # Limit CPU and memory usage for the api service

# Database service (PostgreSQL)  
  db:
    image: postgres:12.1-alpine # Use a lightweight image like Alpine to reduce the image size
    healthcheck: # Ensure db service is healthy before starting api
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 1s
      timeout: 5s
      retries: 10
    volumes:
      - postgres_data_disk:/var/lib/postgresql/data/  # Persist the database data using volumes
    environment: 
      - POSTGRES_USER # Use environment variables from the .env file 
      - POSTGRES_PASSWORD
      - POSTGRES_DB
    networks:
      - app_network  # Adding the service to the same dedicated network
    restart: always  # Restart the database service automatically if it crashes
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M  # Limit CPU and memory usage for the db service
volumes:
  postgres_data_disk:  # Name the volume explicitly to avoid conflicts
    driver: local

networks:
  app_network:  # Define the custom network
    driver: bridge  # Using the default bridge driver